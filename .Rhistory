#install.packages("faraway")
library(faraway)
attach(prostate)
mod_prost<- lm(lpsa~ lcavol+lweight+svi+lbph+age+lcp+gleason+pgg45)
mod_prost
restr_mod<-lm(lpsa~lcp+pgg45+gleason)
r_F<-summary(mod_prost)$r.squared
r_0<-summary(restr_mod)$r.squared
f_stat<-(r_F-r_0)/(1-r_F)
cv<-qf(.95, df1=88, df2=93)
#^ I don't really know if this is the critical value but we'll pretend
f_stat>cv
summary(mod_prost)
nrow(lweight)
dim(lweight)
attr(lweight)
lweight
cv<-qf(.95, df1=88, df2=89)
f_stat>cv
cv<-qf(.95, df1=88, df2=89)
f_stat2>cv
restr_mod2<-lm(lpsa~svi+(two_lweight), data=prostate)
r_F2<-summary(mod_prost)$r.squared
r_02<-summary(restr_mod2)$r.squared
f_stat2<-(r_F2-r_02)/(1-r_F2)
f_stat2
restr_mod2<-lm(lpsa~svi+(two_lweight), data=prostate)
mod_prosttwo<-cbind(mod_prost, two_lweight)
two_lweight<-(2*lweight)
mod_prosttwo<-cbind(mod_prost, two_lweight)
mod_prosttwo
mod_prost
mod_prosttwo<-cbind(lpsa~ lcavol, lweight + svi + lbph + age + lcp +
gleason + pgg45 +two_lweight)
mod_prosttwo<-lm(lpsa~ lcavol, lweight + svi + lbph + age + lcp +
gleason + pgg45 +two_lweight)
mod_prosttwo
mod_prost
gleason
two_lweight
mod_prost<- lm(lpsa~ lcavol+lweight+svi+lbph+age+lcp+gleason+pgg45+two_lweight)
mod_prost
two_lweight)
two_lweight
restr_mod<-lm(lpsa~lcp+pgg45+gleason) round(two_lweight)
round(two_lweight)
two_lweight<-round(two_lweight)
mod_prost<- lm(lpsa~ lcavol+lweight+svi+lbph+age+lcp+gleason+pgg45+two_lweight)
mod_prost
two_lweight<-(2*lweight)
two_lweight
mod_prost<- lm(lpsa~ lcavol+lweight+svi+lbph+age+lcp+gleason+pgg45+two_lweight)
mod_prost
two_lweight<-round(two_lweight,2)
two_lweight
mod_prost<- lm(lpsa~ lcavol+lweight+svi+lbph+age+lcp+gleason+pgg45+two_lweight)
mod_prost
mod_prost<- lm(lpsa~ lcavol+lweight+svi+lbph+age+lcp+gleason+pgg45)
mod_prost
two_lweight<-(2*lweight)
two_lweight
mod_prosttwo<-lm(lpsa~ lcavol, lweight + svi + lbph + age + lcp +
gleason + pgg45 +two_lweight)
two_lweight<-round(2*lweight,3)
mod_prost
mod_prosttwo<-lm(lpsa~ lcavol, lweight + svi + lbph + age + lcp +
gleason + pgg45 +two_lweight)
lcavol
lweight
two_lweight
mod_prosttwo
two_lweight<-round(2*lweight,2)
mod_prosttwo<-lm(lpsa~ lcavol, lweight + svi + lbph + age + lcp +
gleason + pgg45 +two_lweight)
two_lweight<-(2*lweight)
mod_prosttwo<-lm(lpsa~ lcavol+ lweight + svi + lbph + age + lcp +
gleason + pgg45 +two_lweight)
mod_prosttwo
two_lweight<-round(2*lweight,3)
mod_prosttwo<-lm(lpsa~ lcavol+ lweight + svi + lbph + age + lcp +
gleason + pgg45 +two_lweight)
mod_prosttwo
two_lweight<-round(2*lweight,2)
mod_prosttwo<-lm(lpsa~ lcavol+ lweight + svi + lbph + age + lcp +
gleason + pgg45 +two_lweight)
mod_prosttwo
two_lweight<-round(2*lweight,1)
mod_prosttwo<-lm(lpsa~ lcavol+ lweight + svi + lbph + age + lcp +
gleason + pgg45 +two_lweight)
mod_prosttwo
mod_prost
cv<-pf(.95, df1=88, df2=89)
f_stat>cv
cv<-pf(.95, df1=88, df2=89)
f_stat2>cv
mod_prosttwo<-lm(lpsa~ lcavol+ lweight + svi + lbph + age + lcp +
gleason + pgg45 +)
restr_mod2<-lm(lpsa~svi+lweight, data=prostate)
restr_mod2<-lm(lpsa~svi+lweight, data=prostate)
r_F2<-summary(mod_prost)$r.squared
r_02<-summary(restr_mod2)$r.squared
f_stat2<-(r_F2-r_02)/(1-r_F2)
f_stat2
f_stat2>cv
install.packages("devtools")
library(devtools)
integrateIt <- function(x, y, class) {
a<-min(x)
b<-max(y)
if (class == "Trapezoid") {
h <- b - a
trap <- (h / 2) * (f(a) + f(b))
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid",result=(trap), x=, y=, class=)
integrateIt(x,y, rule="Trap")
integrateIt <- function(x, y,.. ) {
a<-min(x)
b<-max(y)
#if (class == "Trapezoid")
{
h <- b - a
trap <- (h / 2) * (f(a) + f(b))
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid",result=(trap), x=x, y=y)
}}
integrateIt <- function(x, y,.. ) {
a<-min(x)
b<-max(y)
#if (class == "Trapezoid")
{
h <- b - a
trap <- (h / 2) * (f(a) + f(b))
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid",result=(trap), x=x, y=y)
}}
integrateIt <- function(x, y,.. ) {
a<-min(x)
b<-max(y)
#if (class == "Trapezoid")
{
h <- b - a
trap <- (h / 2) * (f(a) + f(b))
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid",result=(trap), x=x, y=y))
}}
x<-c(1:10)
y<-seq(2,20,2)
integrateIt(x,y)
integrateIt <- function(x, y,.. ) {
a<-min(x)
b<-max(y)
#if (class == "Trapezoid")
{
h <- b - a
trap <- (h / 2) * (a + b)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid",result=(trap), x=x, y=y))
}}
e
integrateIt(x,y)
integrateIt <- function(x, y,.. ) {
a<-min(x)
b<-max(y)
#if (class == "Trapezoid")
{
h <- b - a
trap <- (h / 2) * (a + b)
x<-as.vector(x)
y<-as.vector(y)
print(x,y, trap) }}
integrateIt(x,y)
library(devtools)
setClass(Class="Trapezoid",
representation = representation(
x = "numeric",
y = "numeric",
dx= "numeric"
),
prototype = prototype(
x = numeric(),
y = numeric(),
dx=numeric()
)
)
#setValidity("Trapezoid", function(object){
if(object@number %in% c(1,2,3)){
return(TRUE)
} else { # if not
return("Input is not a valid value. The number should be between 1 and 3.") # it returns the message that asks to input the number between 1 and 3.
}
})
setClass(Class="Simpson",
representation = representation(
x = "numeric",
y = "numeric",
dx= "numeric"
),
prototype = prototype(
x = numeric(),
y = numeric(),
dx=numeric()
)
)
setGeneric("integrateIt",
def=function(object){
standardGeneric("integret")
})
setMethod(f="integrateIt",
definition=function(x,y,startandend=c(a,b),Rule, ...){
if (Rule=="Trap"){
y_1<-y*2
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
y_1
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/2*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(t), x = x, y = y))
}
if (Rule=="Simpson"){
y_1<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
y_1[i]<-y[i]*4}
else {y_1[i]<-y[i]*2}}
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/3*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(t), x = x, y = y))}
}
)
integrateIt(x,y,startandend=c(2,5),Rule="Simpson")
integrateIt(x,y,startandend=c(2,5),Rule="Trap")
integrateIt <- function(x, y, f){
h <- (b - a) / 2
x0 <- a
x1 <- a + h
x2 <- b
simp_fxdx <- (h / 3) * (f(x0) + 4 * f(x1) + f(x2))
return(simp_fxdx)}
integrateIt(f,0, pi/4)
# make generic print methods for seperate clsas
x<-c(1:10)
y<-seq(2,20,2)
#make a function
integrateIt <- function(fun, a, b, rule) {
if (rule=="Trap"){
# numerical integral of fun from a to b
# using the trapezoid rule with n subdivisions
# assume a < b and n is a positive integer
h <- (b-a)/n
x <- seq(a, b, by=h)
y <- fun(x)
t <- h * (y[1]/2 + sum(y[2:n]) + y[n+1]/2)
return(new("Trapezoid",result=t, a=, b=, class=))
} else {
# numerical integral using Simpson's rule
# assume a < b and n is an even positive integer
h <- (b-a)/n
x <- seq(a, b, by=h)
if (n == 2) {
s <- fun(x[1]) + 4*fun(x[2]) +fun(x[3])
} else {
s <- fun(x[1]) + fun(x[n+1]) + 2*sum(fun(x[seq(2,n,by=2)])) + 4 *sum(fun(x[seq(3,n-1, by=2)]))
}
s <- s*h/3
return(new("Simpson", result=s, a = a, b = b))
}
}
integrateIt(x,y)
setMethod(f="integrateIt",
definition=function(x,y,startandend=c(a,b),Rule, ...){
if (Rule=="Trap"){
y_1<-y*2
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
y_1
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/2*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(t), x = x, y = y))
}
if (Rule=="Simpson"){
y_1<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
y_1[i]<-y[i]*4}
else {y_1[i]<-y[i]*2}}
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/3*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(t), x = x, y = y))}
}
)
integrateIt(x,y,startandend=c(2,5),Rule="Simpson")
integrateIt(x,y,startandend=c(2,5),Rule="Trap")
setGeneric("integrateIt",
def=function(object){
standardGeneric("integret")
})
setMethod(f="integrateIt",
definition=function(x,y,startandend=c(a,b),Rule, ...){
if (Rule=="Trap"){
y_1<-y*2
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
y_1
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/2*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(t), x = x, y = y))
}
if (Rule=="Simpson"){
y_1<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
y_1[i]<-y[i]*4}
else {y_1[i]<-y[i]*2}}
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/3*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(t), x = x, y = y))}
}
)
integrateIt(x,y,startandend=c(2,5),Rule="Simpson")
integrateIt(x,y,startandend=c(2,5),Rule="Trap")
setGeneric(name="integrateIt",
def=function(x,y,startandend,Rule, ...)
{standardGeneric("integrateIt")}
)
setMethod(f="integrateIt",
definition=function(x,y,startandend=c(a,b),Rule, ...){
if (Rule=="Trap"){
y_1<-y*2
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
y_1
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/2*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(t), x = x, y = y))
}
if (Rule=="Simpson"){
y_1<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
y_1[i]<-y[i]*4}
else {y_1[i]<-y[i]*2}}
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/3*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(t), x = x, y = y))}
}
)
integrateIt(x,y,startandend=c(2,5),Rule="Simpson")
integrateIt(x,y,startandend=c(2,5),Rule="Trap")
x<-c(1:10)
y<-seq(2,20,2)
integrateIt(x,y,startandend=c(2,5),Rule="Simpson")
setGeneric(name="integrateIt",
def=function(x, y, bounds, rule)
{standardGeneric("integrateIt")}
)
setMethod(f="integrateIt",
definition=function(x,y,bounds=c(a,b),rule){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
if (rule=="Trap"){
trapvec<-y*2
trapvec[1]<-y[1]
trapvec[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapoutput<-h/2*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(trapoutput), x = x, y = y))
}
if (rule=="Simpson"){
simpvec<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
simpvec[i]<-y[i]*4}
else {simpvec[i]<-y[i]*2}}
simpvec[1]<-y[1]
simpvec[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
simpoutput<-h/3*(simpvec)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(simpoutput), x = x, y = y))}
}
)
x<-c(1:10)
y<-seq(2,20,2)
integrateIt(x,y,bounds=c(2,5), class="Trap")
integrateIt(x,y,bounds=c(2,5), rule="Trap")
x<-c(1:10)
y<-seq(2,20,2)
x
y
setMethod(f="integrateIt",
definition=function(x,y,bounds=c(a,b),rule){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
if (rule=="Trap"){
trapvec<-y*2
trapvec[1]<-y[1]
trapvec[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapoutput<-h/2*(trapvec)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(trapoutput), x = x, y = y))
}
if (rule=="Simpson"){
simpvec<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
simpvec[i]<-y[i]*4}
else {simpvec[i]<-y[i]*2}}
simpvec[1]<-y[1]
simpvec[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
simpoutput<-h/3*(simpvec)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(simpoutput), x = x, y = y))}
}
)
x<-c(1:10)
y<-seq(2,20,2)
integrateIt(x,y,bounds=c(2,5), rule="Trap")
setClass(Class="Trapezoid",
representation = representation(
result = "numeric",
x="numeric",
y="numeric"
),
prototype = prototype(
result =  c(),
x= c(),
y= c())
)
setClass(Class="Simpson",
representation = representation(
result = "numeric",
x="numeric",
y="numeric"
),
prototype = prototype(
result =  c(),
x= c(),
y= c())
)
integrateIt(x,y,bounds=c(2,5), rule="Trap")
integrateIt(x,y,bounds=c(2,5), rule="Simp")
integrateIt(x,y,bounds=c(2,5), rule="Simpson")
x<-c(0:10)
y<-seq(2,20,2)
integrateIt(x,y,bounds=c(2,5), rule="Trap")
integrateIt(x,y,bounds=c(1,10), rule="Trap")
integrateIt(x,y,bounds=c(0,10), rule="Trap")
integrateIt(x,y,bounds=c(0,10), rule="Simpson")
x<-c(0:10)
y<-seq(2,20,2)
integrateIt(x,y,bounds=c(0,10), rule="Simpson")
y<-seq(0,20,2)
integrateIt(x,y,bounds=c(0,10), rule="Trap")
integrateIt(x,y,bounds=c(0,10), rule="Simpson")
## This can be run many times as the code is updates
current.code <- as.package("integrateIt")
setwd("C:/Users/dl0ck/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8/PS5") #This will need to be changed to match your directory
setwd("C:/Users/dl0ck/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8/PS5") #This will need to be changed to match your directory
setwd("C:/Users/dl0ck/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8") #This will need to be changed to match your directory
setwd("C:/Users/dl0ck/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8/PS5") #This will need to be changed to match your directory
setwd("C:/Users/dl0ck/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8/PS5/") #This will need to be changed to match your directory
library(devtools)
library(roxygen2)
## This can be run many times as the code is updates
current.code <- as.package("integrateIt")
setwd("C:\Users\Dominique\OneDrive\Documents\Spring 2018\Applied Statistical Programming\git\Week 8\PS5")
setwd("C:/Users/Dominique/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8/PS5/") #This will need to be changed to match your directory
library(devtools)
library(roxygen2)
## This can be run many times as the code is updates
current.code <- as.package("integrateIt")
load_all(current.code)
