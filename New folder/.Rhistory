y<-as.vector(y)
print(x,y, trap) }}
integrateIt(x,y)
library(devtools)
setClass(Class="Trapezoid",
representation = representation(
x = "numeric",
y = "numeric",
dx= "numeric"
),
prototype = prototype(
x = numeric(),
y = numeric(),
dx=numeric()
)
)
#setValidity("Trapezoid", function(object){
if(object@number %in% c(1,2,3)){
return(TRUE)
} else { # if not
return("Input is not a valid value. The number should be between 1 and 3.") # it returns the message that asks to input the number between 1 and 3.
}
})
setClass(Class="Simpson",
representation = representation(
x = "numeric",
y = "numeric",
dx= "numeric"
),
prototype = prototype(
x = numeric(),
y = numeric(),
dx=numeric()
)
)
setGeneric("integrateIt",
def=function(object){
standardGeneric("integret")
})
setMethod(f="integrateIt",
definition=function(x,y,startandend=c(a,b),Rule, ...){
if (Rule=="Trap"){
y_1<-y*2
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
y_1
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/2*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(t), x = x, y = y))
}
if (Rule=="Simpson"){
y_1<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
y_1[i]<-y[i]*4}
else {y_1[i]<-y[i]*2}}
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/3*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(t), x = x, y = y))}
}
)
integrateIt(x,y,startandend=c(2,5),Rule="Simpson")
integrateIt(x,y,startandend=c(2,5),Rule="Trap")
integrateIt <- function(x, y, f){
h <- (b - a) / 2
x0 <- a
x1 <- a + h
x2 <- b
simp_fxdx <- (h / 3) * (f(x0) + 4 * f(x1) + f(x2))
return(simp_fxdx)}
integrateIt(f,0, pi/4)
# make generic print methods for seperate clsas
x<-c(1:10)
y<-seq(2,20,2)
#make a function
integrateIt <- function(fun, a, b, rule) {
if (rule=="Trap"){
# numerical integral of fun from a to b
# using the trapezoid rule with n subdivisions
# assume a < b and n is a positive integer
h <- (b-a)/n
x <- seq(a, b, by=h)
y <- fun(x)
t <- h * (y[1]/2 + sum(y[2:n]) + y[n+1]/2)
return(new("Trapezoid",result=t, a=, b=, class=))
} else {
# numerical integral using Simpson's rule
# assume a < b and n is an even positive integer
h <- (b-a)/n
x <- seq(a, b, by=h)
if (n == 2) {
s <- fun(x[1]) + 4*fun(x[2]) +fun(x[3])
} else {
s <- fun(x[1]) + fun(x[n+1]) + 2*sum(fun(x[seq(2,n,by=2)])) + 4 *sum(fun(x[seq(3,n-1, by=2)]))
}
s <- s*h/3
return(new("Simpson", result=s, a = a, b = b))
}
}
integrateIt(x,y)
setMethod(f="integrateIt",
definition=function(x,y,startandend=c(a,b),Rule, ...){
if (Rule=="Trap"){
y_1<-y*2
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
y_1
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/2*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(t), x = x, y = y))
}
if (Rule=="Simpson"){
y_1<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
y_1[i]<-y[i]*4}
else {y_1[i]<-y[i]*2}}
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/3*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(t), x = x, y = y))}
}
)
integrateIt(x,y,startandend=c(2,5),Rule="Simpson")
integrateIt(x,y,startandend=c(2,5),Rule="Trap")
setGeneric("integrateIt",
def=function(object){
standardGeneric("integret")
})
setMethod(f="integrateIt",
definition=function(x,y,startandend=c(a,b),Rule, ...){
if (Rule=="Trap"){
y_1<-y*2
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
y_1
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/2*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(t), x = x, y = y))
}
if (Rule=="Simpson"){
y_1<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
y_1[i]<-y[i]*4}
else {y_1[i]<-y[i]*2}}
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/3*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(t), x = x, y = y))}
}
)
integrateIt(x,y,startandend=c(2,5),Rule="Simpson")
integrateIt(x,y,startandend=c(2,5),Rule="Trap")
setGeneric(name="integrateIt",
def=function(x,y,startandend,Rule, ...)
{standardGeneric("integrateIt")}
)
setMethod(f="integrateIt",
definition=function(x,y,startandend=c(a,b),Rule, ...){
if (Rule=="Trap"){
y_1<-y*2
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
y_1
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/2*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(t), x = x, y = y))
}
if (Rule=="Simpson"){
y_1<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
y_1[i]<-y[i]*4}
else {y_1[i]<-y[i]*2}}
y_1[1]<-y[1]
y_1[ncol(y)]<-y[ncol(y)]
h<-(startandend[2]-startandend[1])/nrow(x)
t<-h/3*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(t), x = x, y = y))}
}
)
integrateIt(x,y,startandend=c(2,5),Rule="Simpson")
integrateIt(x,y,startandend=c(2,5),Rule="Trap")
x<-c(1:10)
y<-seq(2,20,2)
integrateIt(x,y,startandend=c(2,5),Rule="Simpson")
setGeneric(name="integrateIt",
def=function(x, y, bounds, rule)
{standardGeneric("integrateIt")}
)
setMethod(f="integrateIt",
definition=function(x,y,bounds=c(a,b),rule){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
if (rule=="Trap"){
trapvec<-y*2
trapvec[1]<-y[1]
trapvec[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapoutput<-h/2*(y_1)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(trapoutput), x = x, y = y))
}
if (rule=="Simpson"){
simpvec<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
simpvec[i]<-y[i]*4}
else {simpvec[i]<-y[i]*2}}
simpvec[1]<-y[1]
simpvec[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
simpoutput<-h/3*(simpvec)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(simpoutput), x = x, y = y))}
}
)
x<-c(1:10)
y<-seq(2,20,2)
integrateIt(x,y,bounds=c(2,5), class="Trap")
integrateIt(x,y,bounds=c(2,5), rule="Trap")
x<-c(1:10)
y<-seq(2,20,2)
x
y
setMethod(f="integrateIt",
definition=function(x,y,bounds=c(a,b),rule){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
if (rule=="Trap"){
trapvec<-y*2
trapvec[1]<-y[1]
trapvec[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapoutput<-h/2*(trapvec)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(trapoutput), x = x, y = y))
}
if (rule=="Simpson"){
simpvec<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
simpvec[i]<-y[i]*4}
else {simpvec[i]<-y[i]*2}}
simpvec[1]<-y[1]
simpvec[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
simpoutput<-h/3*(simpvec)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(simpoutput), x = x, y = y))}
}
)
x<-c(1:10)
y<-seq(2,20,2)
integrateIt(x,y,bounds=c(2,5), rule="Trap")
setClass(Class="Trapezoid",
representation = representation(
result = "numeric",
x="numeric",
y="numeric"
),
prototype = prototype(
result =  c(),
x= c(),
y= c())
)
setClass(Class="Simpson",
representation = representation(
result = "numeric",
x="numeric",
y="numeric"
),
prototype = prototype(
result =  c(),
x= c(),
y= c())
)
integrateIt(x,y,bounds=c(2,5), rule="Trap")
integrateIt(x,y,bounds=c(2,5), rule="Simp")
integrateIt(x,y,bounds=c(2,5), rule="Simpson")
x<-c(0:10)
y<-seq(2,20,2)
integrateIt(x,y,bounds=c(2,5), rule="Trap")
integrateIt(x,y,bounds=c(1,10), rule="Trap")
integrateIt(x,y,bounds=c(0,10), rule="Trap")
integrateIt(x,y,bounds=c(0,10), rule="Simpson")
x<-c(0:10)
y<-seq(2,20,2)
integrateIt(x,y,bounds=c(0,10), rule="Simpson")
y<-seq(0,20,2)
integrateIt(x,y,bounds=c(0,10), rule="Trap")
integrateIt(x,y,bounds=c(0,10), rule="Simpson")
## This can be run many times as the code is updates
current.code <- as.package("integrateIt")
setwd("C:/Users/dl0ck/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8/PS5") #This will need to be changed to match your directory
setwd("C:/Users/dl0ck/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8/PS5") #This will need to be changed to match your directory
setwd("C:/Users/dl0ck/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8") #This will need to be changed to match your directory
trap<-function(x,y,bounds=c(a,b),rule){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
trap<-y*2
trap[1]<-y[1]
trap[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapintegr<-h/2*(trap)
x<-as.vector(x)
y<-as.vector(y)
print(trap, x, y)}
x<-seq(1,11,1)
y<-seq(11,21,1)
trap<-function(x,y,bounds=c(a,b),rule){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
trap<-y*2
trap[1]<-y[1]
trap[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapintegr<-h/2*(trap)
x<-as.vector(x)
y<-as.vector(y)
print(trap, x, y)}
trap(x,y), bounds=c(1,10))
trap<-function(x,y,bounds=c(a,b)){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
trap<-y*2
trap[1]<-y[1]
trap[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapintegr<-h/2*(trap)
x<-as.vector(x)
y<-as.vector(y)
print(trap, x, y)}
trap(x,y, bounds=c(1,10))
trap<-function(x,y,bounds=c(a,b)){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
trap<-y*2
trap[1]<-y[1]
trap[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapintegr<-h/2*(trap)
x<-as.vector(x)
y<-as.vector(y)
return(trap, x, y)}
trap(x,y, bounds=c(1,10))
trap<-function(x,y,bounds=c(a,b)){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
trap<-y*2
trap[1]<-y[1]
trap[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapintegr<-h/2*(trap)
x<-as.vector(x)
y<-as.vector(y)
return(list(trap, x, y))}
trap(x,y, bounds=c(1,10))
trap<-function(x,y,bounds=c(a,b)){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
trap<-y*2
trap[1]<-y[1]
trap[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapintegr<-h/2*(trap)
x<-as.vector(x)
y<-as.vector(y)
return(list(sum(trap), x, y))}
trap(x,y, bounds=c(1,10))
trap(x,y, bounds=c(1,10))
x<-seq(1,11,1)
y<-seq(11,21,1)
trap<-function(x,y,bounds=c(a,b)){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
trap<-y*2
trap[1]<-y[1]
trap[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapintegr<-h/2*(trap)
x<-as.vector(x)
y<-as.vector(y)
return(list(trapintegr, x, y))}
trap(x,y, bounds=c(1,10))
x<-seq(1,11,1)
y<-seq(11,21,1)
trap<-function(x,y,bounds=c(a,b)){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
trap<-y*2
trap[1]<-y[1]
trap[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapintegr<-h/2*(trap)
x<-as.vector(x)
y<-as.vector(y)
return(list(sum(trapintegr), x, y))}
trap(x,y, bounds=c(1,10))
function(x,y,a,b,rule="trap"){
n=length(x)
}
trap(x,y, bounds=c(1,10))
x<-seq(1,11,1)
y<-seq(11,21,1)
setGeneric(name="integrateIt",
def=function(x, y, bounds, rule)
{standardGeneric("integrateIt")}
)
setMethod(f="integrateIt",
definition=function(x,y,bounds=c(a,b),rule){
x<-as.matrix(x)
x<-t(x)
y<-as.matrix(y)
y<-t(y)
if (rule=="trap"){
trap<-y*2
trap[1]<-y[1]
trap[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
trapintegr<-h/2*(trap)
x<-as.vector(x)
y<-as.vector(y)
return(new("Trapezoid", result=sum(trapintegr), x = x, y = y))
}
if (rule=="simp"){
simp<-y
for (i in 1:ncol(y)){
if((i %% 2) == 0){
simp[i]<-y[i]*4}
else {simp[i]<-y[i]*2}}
simp[1]<-y[1]
simp[ncol(y)]<-y[ncol(y)]
h<-(bounds[2]-bounds[1]+1)/ncol(x)
simpintegr<-h/3*(simp)
x<-as.vector(x)
y<-as.vector(y)
return(new("Simpson", result=sum(simpintegr), x = x, y = y))}
}
)
x<-seq(1,11,1)
y<-seq(11,21,1)
integrateIt(x,y,bounds=c(0,10), rule="trap")
integrateIt(x,y,bounds=c(0,10), rule="simp")
integrateIt(x,y,bounds=c(1,10), rule="trap")
integrateIt(x,y,bounds=c(1,10), rule="simp")
## This can be run many times as the code is updates
current.code <- as.package("integrateIt")
library(devtools)
library(roxygen2)
## This can be run many times as the code is updates
current.code <- as.package("integrateIt")
setwd("C:/Users/dl0ck/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8/PS5") #This will need to be changed to match your directory
setwd("C:/Users/dl0ck/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8/PS5") #This will need to be changed to match your directory
setwd("C:/Users/Dominique/OneDrive/Documents/Spring 2018/Applied Statistical Programming/git/Week 8/PS5")
library(devtools)
library(roxygen2)
## This can be run many times as the code is updates
current.code <- as.package("integrateIt")
load_all(current.code)
## This can be run many times as the code is updates
current.code <- as.package("integrateIt")
load_all(current.code)
## This can be run many times as the code is updates
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
